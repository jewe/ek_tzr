
// forum.processing.org/two/discussion/10894/
// how-do-i-resize-the-output-of-my-capture-video
 
// 2018-May-19
// this scripit will take image from connected camera (#1 on the list), resize it to resolution of the flipdot board and turn into black and white
 
 
import processing.video.Capture;
import processing.serial.*;

Capture c;
 
PImage img;
 // The serial port:

 
Serial myPort;       




void SendFDot(PImage img2send)
{
  int adres=0; // first panel address, assumed to be like rading starting from 0 //<>//
  int data =0x00;
  int F=width/28; // width of the screen in 28 wide panels   
  int T=height/7; // height of the screen in 7 high panels
  
  int x;
  int y;
  int z;
  int r;
  int u;
  
  int send_buffer[]={ 0x80, 0x84, 0xFF, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00};
  
     
   
loadPixels(); // load pixels from image2send  

for (x=0;x<F;x++)  // counting panels horizontally  F
      for (y=0;y<T; y++) // counting panels vertically T
              {
 
              // sending a transmission for each 7x28 panel                                                   
                                
                          for (r=0;r<28;r++){  // counting columns of a panel
                                              data=0x00; // set data byte to zero before calculating it for another column of 7 dots
                                              send_buffer[2] = x + (y*F); // address of a panel

                                                for (z=0;z<7;z++) data = (data + ((pixels[(y*28*F*7)+((6-z)*F*28)+(x*28)+r]&0x01)))<<1; // take pixel, take last bit, move bitwise by one bit and and add to data
                                                send_buffer[r+3]=data>>1; // write data calculated for each column into string to send
                                                           
                                            };
                                                               
              for (u=0;u<33; u++) myPort.write(send_buffer[u]); // send transmission for one panel


};

// refresh allpanels

myPort.write(0x80); //header
myPort.write(0x82); // refresh

myPort.write(0x8F); // end



}
  

 
void set_pixel(int stan)
{
  
 byte datab=0x00;
 
 if (stan==1) datab=byte(0xFF);
 if (stan==0) datab=byte(0x00);
  
if (myPort.available() > 1)               myPort.write(0x80); //header
if (myPort.available() > 1)               myPort.write(0x83); // send data with no refresh 0x84 / wiuth refresh 0x83
if (myPort.available() > 1)               myPort.write(0xFF); // assuming we have addresses like reading from left to right, from up to bottom
            
                  for (int r=0;r<28;r++)     
                            myPort.write(datab);
                  
if (myPort.available() > 1)               myPort.write(0x8F); // assuming we have addresses like reading from left to right, from up to bottom


};



void setup() {
  
  // here put resolution of your sign: one panel is 28 x 14)
  
  size(56, 28, JAVA2D);
  noLoop();
  frameRate(15);
  
  printArray(Serial.list());

// Open the port you are using at the rate you want:
myPort = new Serial(this, Serial.list()[5], 57600);

// if you want to show a static image, you can put it here.
//img=loadImage("strips.png");
//img.resize(width, height);
//img.filter(THRESHOLD,0.9765);
 

 
  String[] cams = Capture.list();
  printArray(cams);
 
  (c = new Capture(this, cams[1])).start();
  while (img == null || img.width != width)  delay(10);
  
}


 
void draw() {
 int t=0;
  
  
//image(img,0,0);
 // SendFDot(img);
  //delay(1000);
  
  background(img);
  surface.setTitle(str(round(frameRate)));
 
  
  
}
 


void captureEvent(Capture capture) {
  capture.read();
 PImage pic = capture.get();
  pic.resize(width, height); //<>//
 // by changin the threshold parameter you can adjust what you really see 
  pic.filter(THRESHOLD,0.6);
 
  img = pic;
  SendFDot(img);
 
  redraw = true;
  
  
  
  
  
  
}